<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #fafafa;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 40px 20px 120px;
      color: #1a1a1a;
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #fafafa;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.2s;
    }

    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #e0e0e0;
      border-top-color: #1a1a1a;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* New round announcement */
    .round-announcement {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(26, 26, 26, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .round-announcement.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .round-announcement .round-number {
      font-size: 6rem;
      font-weight: 700;
      color: #fff;
      line-height: 1;
      animation: round-pop 0.5s ease-out;
    }

    .round-announcement .round-label {
      font-size: 1.5rem;
      color: rgba(255,255,255,0.7);
      text-transform: uppercase;
      letter-spacing: 4px;
      margin-bottom: 16px;
    }

    .round-announcement .round-title {
      font-size: 1.2rem;
      color: rgba(255,255,255,0.5);
      margin-top: 16px;
    }

    @keyframes round-pop {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    .header {
      text-align: center;
      margin-bottom: 32px;
    }

    .cta {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 16px;
      color: #1a1a1a;
    }

    .cta.voted {
      color: #43a047;
    }

    .cta.closed {
      color: #43a047;
    }

    .round-info {
      font-size: 1rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 500;
    }

    .round-name {
      font-size: 1.2rem;
      margin-top: 8px;
      color: #1a1a1a;
      font-weight: 600;
    }

    .round-name:empty {
      display: none;
    }

    .voting-container {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      width: 100%;
      max-width: 800px;
      justify-content: center;
    }

    .team-btn {
      flex: 1 1 calc(50% - 16px);
      min-width: 200px;
      max-width: 300px;
      padding: 40px 20px;
      border: 3px solid #1a1a1a;
      border-radius: 16px;
      font-size: 1.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      background: #fff;
      color: #1a1a1a;
    }

    .team-btn:hover:not(:disabled) {
      color: #fff;
      transform: scale(1.02);
    }

    .team-btn:active:not(:disabled) {
      transform: scale(0.98);
    }

    .team-btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .team-btn.selected {
      color: #fff;
    }

    .vote-count {
      font-size: 3rem;
      font-weight: 700;
      line-height: 1;
      display: none;
    }

    .vote-count.visible {
      display: block;
    }

    /* Winner styles */
    .team-btn.winner {
      transform: scale(1.08);
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      opacity: 1 !important;
      color: #fff;
      animation: winner-pulse 1.5s ease-in-out infinite;
    }

    .team-btn.loser {
      opacity: 0.4;
      transform: scale(0.95);
    }

    @keyframes winner-pulse {
      0%, 100% { box-shadow: 0 8px 32px rgba(0,0,0,0.2); }
      50% { box-shadow: 0 12px 48px rgba(0,0,0,0.3); }
    }

    .winner-badge {
      font-size: 1rem;
      background: #fff;
      color: #1a1a1a;
      padding: 8px 16px;
      border-radius: 24px;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 700;
      margin-top: 8px;
    }

    /* Tie styles */
    .team-btn.tied {
      color: #fff;
      opacity: 1;
    }

    .tie-badge {
      font-size: 0.9rem;
      background: rgba(255,255,255,0.9);
      color: #1a1a1a;
      padding: 6px 14px;
      border-radius: 20px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      margin-top: 8px;
    }

    .trophy {
      font-size: 2rem;
      line-height: 1;
    }

    /* Mini confetti */
    .confetti {
      position: fixed;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      animation: confetti-fall 2s ease-out forwards;
      z-index: 1000;
    }

    @keyframes confetti-fall {
      0% {
        opacity: 1;
        transform: translateY(0) rotate(0deg) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(100px) rotate(720deg) scale(0.5);
      }
    }

    .team-name {
      font-size: 1rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
    }

    .confirm-section {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      text-align: center;
      z-index: 100;
    }

    .confirm-btn {
      width: 100%;
      max-width: 400px;
      padding: 18px 48px;
      font-size: 1.2rem;
      font-weight: 600;
      border: 3px solid #43a047;
      border-radius: 12px;
      background: #43a047;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 16px rgba(67, 160, 71, 0.4);
    }

    .confirm-btn:hover {
      background: #388e3c;
      border-color: #388e3c;
      transform: scale(1.02);
    }

    .confirm-btn:active {
      transform: scale(0.98);
    }

    .confirm-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .confirm-btn.hidden {
      display: none;
    }

    .selected-info {
      margin-bottom: 12px;
      font-size: 1rem;
      color: #666;
    }

    .selected-info .team-name {
      font-weight: 600;
      color: #1a1a1a;
    }

    .selected-info.hidden {
      display: none;
    }

    .total-voters {
      margin-top: 24px;
      color: #999;
      font-size: 0.85rem;
      display: none;
    }

    .total-voters.visible {
      display: block;
    }

    /* Vote progress bar */
    .vote-progress {
      width: 100%;
      max-width: 400px;
      margin-top: 32px;
      text-align: center;
    }

    .vote-progress.hidden {
      display: none;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: #43a047;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 0.85rem;
      color: #666;
    }

    .progress-text span {
      font-weight: 600;
      color: #1a1a1a;
    }

    /* Joke mode cooldown button */
    .cooldown-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      padding: 18px;
      font-size: 1.2rem;
      font-weight: 600;
      border: 3px solid #e0e0e0;
      border-radius: 12px;
      background: #e0e0e0;
      color: #999;
      text-align: center;
      z-index: 100;
    }

    .cooldown-btn.hidden {
      display: none;
    }

    .cooldown-btn .timer {
      display: inline-block;
      width: 24px;
      height: 24px;
      line-height: 24px;
      background: #999;
      color: #fff;
      border-radius: 50%;
      font-size: 0.9rem;
      margin-left: 8px;
    }

    .team-btn.winner {
      color: #fff;
      transform: scale(1.05);
    }

    @media (max-width: 480px) {
      .team-btn {
        flex: 1 1 100%;
        max-width: none;
        padding: 30px 20px;
      }

      .vote-count {
        font-size: 2.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="cta" id="cta">–ì–æ–ª–æ—Å—É–π –∑–∞ –ª—É—á—à—É—é –∫–æ–º–∞–Ω–¥—É!</div>
    <div class="round-info">–†–∞—É–Ω–¥ <span id="round">1</span></div>
    <div class="round-name" id="round-name"></div>
  </div>

  <div class="loading-overlay" id="loading-overlay">
    <div class="loading-spinner"></div>
  </div>

  <div class="round-announcement" id="round-announcement">
    <div class="round-label">–†–∞—É–Ω–¥</div>
    <div class="round-number" id="announcement-number">1</div>
    <div class="round-title" id="announcement-title"></div>
  </div>

  <div class="voting-container" id="voting-container">
    <!-- Teams will be rendered here -->
  </div>

  <div class="confirm-section" id="confirm-section">
    <div class="selected-info hidden" id="selected-info"></div>
    <button class="confirm-btn hidden" id="confirm-btn" onclick="confirmVote()">
      –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å
    </button>
  </div>

  <div class="cooldown-btn hidden" id="cooldown-btn">
    –ü–æ–¥–æ–∂–¥–∏—Ç–µ <span class="timer" id="cooldown-timer">3</span>
  </div>

  <div class="total-voters" id="total-voters"></div>

  <div class="vote-progress hidden" id="vote-progress">
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
    </div>
    <div class="progress-text">–ü—Ä–æ–≥–æ–ª–æ—Å–æ–≤–∞–ª–æ <span id="voted-count">0</span> –∏–∑ <span id="total-count">0</span></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();

    // Request state immediately on connect
    socket.on('connect', () => {
      socket.emit('get-state');
    });

    let teams = [];
    let votedFor = null;        // Confirmed vote
    let selectedTeam = null;    // Pre-selected (not confirmed yet)
    let votingOpen = true;
    let jokeMode = false;       // Joke counter mode
    let jokeCooldown = false;   // Cooldown active
    let cooldownTimer = null;   // Timer reference
    let cooldownSeconds = 0;    // Remaining seconds
    let visitorId = null;
    let visitorKey = null;
    let currentVoteSession = null;

    // Generate device fingerprint (sync where possible)
    function getFingerprint() {
      try {
        // Try localStorage first (persists across sessions)
        const stored = localStorage.getItem('voter_fingerprint');
        if (stored) {
          const data = JSON.parse(stored);
          visitorId = data.visitorId;
          visitorKey = data.visitorKey;
          return Promise.resolve();
        }
      } catch (e) {}

      // Generate new fingerprint based on device characteristics
      const components = [
        navigator.userAgent,
        navigator.language,
        screen.width + 'x' + screen.height,
        screen.colorDepth,
        new Date().getTimezoneOffset(),
        navigator.hardwareConcurrency || 'unknown',
        navigator.platform,
        getCanvasFingerprint()
      ];

      // Create hash
      const fingerprint = components.join('|');
      return hashString(fingerprint).then(hash => {
        visitorId = hash;
        visitorKey = hash + '-' + Date.now();
        // Store in localStorage
        try {
          localStorage.setItem('voter_fingerprint', JSON.stringify({ visitorId, visitorKey }));
        } catch (e) {}
      });
    }

    function getCanvasFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 200;
        canvas.height = 50;
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText('Fp', 2, 15);
        return canvas.toDataURL().slice(-50);
      } catch (e) {
        return 'no-canvas';
      }
    }

    function hashString(str) {
      // Simple fast hash for fingerprint
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Promise.resolve(Math.abs(hash).toString(36) + str.length.toString(36));
    }

    // Initialize
    function init() {
      getFingerprint().then(() => {
        // Check if voted in localStorage
        const localVote = localStorage.getItem('current_vote');
        if (localVote) {
          try {
            const voteData = JSON.parse(localVote);
            if (voteData.visitorId === visitorId) {
              votedFor = voteData.teamId;
            }
          } catch (e) {}
        }
        // Register with server
        socket.emit('register-fingerprint', { visitorId, visitorKey });
      });
    }

    init();

    // Loading overlay for initial load and reconnects
    const loadingOverlay = document.getElementById('loading-overlay');
    let awaitingState = true;

    function showLoader() {
      awaitingState = true;
      loadingOverlay.classList.remove('hidden');
    }

    function hideLoader() {
      awaitingState = false;
      loadingOverlay.classList.add('hidden');
    }

    // Round announcement
    const roundAnnouncement = document.getElementById('round-announcement');

    function showRoundAnnouncement(roundNum, roundTitle) {
      document.getElementById('announcement-number').textContent = roundNum;
      const titleEl = document.getElementById('announcement-title');
      titleEl.textContent = roundTitle || '';
      titleEl.style.display = roundTitle ? 'block' : 'none';

      roundAnnouncement.classList.add('visible');

      // Auto-hide after 2 seconds
      setTimeout(() => {
        roundAnnouncement.classList.remove('visible');
      }, 2000);
    }

    function requestSync() {
      // Show loader when reconnecting after sleep
      if (!socket.connected) {
        showLoader();
        socket.connect();
      }
      socket.emit('get-state');
      if (visitorId) {
        socket.emit('register-fingerprint', { visitorId, visitorKey });
      }
    }

    // Re-sync state when user returns to page (after switching tabs/apps)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        requestSync();
      }
    });

    // Also handle page focus (backup for visibilitychange)
    window.addEventListener('focus', requestSync);

    // Handle socket reconnection
    socket.on('reconnect', requestSync);

    function renderTeams() {
      const container = document.getElementById('voting-container');
      const isSelected = (id) => votedFor === id || selectedTeam === id;
      const showResults = !votingOpen; // Only show results when voting is closed

      // Find winner when showing results
      const maxVotes = showResults ? Math.max(...teams.map(t => t.votes)) : 0;
      const hasVotes = maxVotes > 0;
      const winnersCount = hasVotes ? teams.filter(t => t.votes === maxVotes).length : 0;
      const isTie = winnersCount > 1; // –ù–∏—á—å—è –µ—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–º–∞–Ω–¥ —Å max –≥–æ–ª–æ—Å–∞–º–∏

      // Sort teams: winner first, then by votes descending
      const sortedTeams = showResults
        ? [...teams].sort((a, b) => b.votes - a.votes)
        : teams;

      container.innerHTML = sortedTeams.map((team, index) => {
        const isWinner = showResults && hasVotes && !isTie && team.votes === maxVotes;
        const isLoser = showResults && hasVotes && !isTie && team.votes !== maxVotes;
        const isTied = showResults && hasVotes && isTie && team.votes === maxVotes;

        // Only disable during active voting if already voted, not when results shown
        // In joke mode, only disable during cooldown; in normal mode, disable after voting
        const shouldDisable = jokeMode
          ? (votingOpen && jokeCooldown)
          : (votingOpen && votedFor !== null);

        // Trophy for places when showing results
        const place = showResults && hasVotes ? index + 1 : 0;
        const trophy = isTie ? '' : (place === 1 ? 'ü•á' : place === 2 ? 'ü•à' : place === 3 ? 'ü•â' : '');

        return `
          <button
            class="team-btn ${isSelected(team.id) ? 'selected' : ''} ${isWinner ? 'winner' : ''} ${isLoser ? 'loser' : ''} ${isTied ? 'tied' : ''}"
            style="border-color: ${team.color}; ${isSelected(team.id) || isWinner || isTied ? `background: ${team.color}` : ''}"
            data-id="${team.id}"
            data-color="${team.color}"
            ${shouldDisable ? 'disabled' : ''}
            onclick="selectTeam(${team.id})"
          >
            ${trophy ? `<span class="trophy">${trophy}</span>` : ''}
            <span class="team-name">${team.name}</span>
            <span class="vote-count ${showResults ? 'visible' : ''}">${team.votes}</span>
            ${isWinner ? '<span class="winner-badge">–ü–æ–±–µ–¥–∏—Ç–µ–ª—å</span>' : ''}
            ${isTied ? '<span class="tie-badge">–ù–∏—á—å—è</span>' : ''}
          </button>
        `;
      }).join('');

      // Add hover effects
      container.querySelectorAll('.team-btn:not(:disabled)').forEach(btn => {
        const color = btn.dataset.color;
        btn.addEventListener('mouseenter', () => {
          if (!btn.classList.contains('selected')) {
            btn.style.background = color;
          }
        });
        btn.addEventListener('mouseleave', () => {
          if (!btn.classList.contains('selected')) {
            btn.style.background = '#fff';
          }
        });
      });

      // Update confirm button
      updateConfirmButton();
    }

    // Mini confetti burst
    function miniConfetti() {
      const colors = ['#e53935', '#1e88e5', '#43a047', '#fb8c00', '#8e24aa', '#fdd835'];
      const count = 30;

      for (let i = 0; i < count; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.top = Math.random() * 40 + 'vh';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        document.body.appendChild(confetti);

        setTimeout(() => confetti.remove(), 2500);
      }
    }

    function updateConfirmButton() {
      const confirmBtn = document.getElementById('confirm-btn');
      const selectedInfo = document.getElementById('selected-info');

      // In joke mode, never show confirm button
      if (jokeMode) {
        confirmBtn.classList.add('hidden');
        selectedInfo.classList.add('hidden');
        return;
      }

      if (votedFor !== null) {
        // Already voted
        confirmBtn.classList.add('hidden');
        selectedInfo.classList.add('hidden');
      } else if (selectedTeam !== null && votingOpen) {
        // Team selected, show confirm
        const team = teams.find(t => t.id === selectedTeam);
        if (team) {
          selectedInfo.innerHTML = `–í—ã –≤—ã–±—Ä–∞–ª–∏: <span class="team-name">${team.name}</span>`;
          selectedInfo.classList.remove('hidden');
        }
        confirmBtn.classList.remove('hidden');
      } else {
        // Nothing selected
        confirmBtn.classList.add('hidden');
        selectedInfo.classList.add('hidden');
      }
    }

    function selectTeam(teamId) {
      if (!votingOpen) return;

      // Joke mode - vote immediately with cooldown
      if (jokeMode) {
        if (jokeCooldown) return; // Still in cooldown
        socket.emit('vote', { teamId, visitorId, visitorKey });
        startCooldown();
        return;
      }

      // Normal mode - select and confirm
      if (votedFor !== null) return;
      selectedTeam = teamId;
      renderTeams();
    }

    function startCooldown() {
      jokeCooldown = true;
      cooldownSeconds = 3;
      updateCooldownUI();

      cooldownTimer = setInterval(() => {
        cooldownSeconds--;
        if (cooldownSeconds <= 0) {
          clearInterval(cooldownTimer);
          jokeCooldown = false;
          document.getElementById('cooldown-btn').classList.add('hidden');
        } else {
          updateCooldownUI();
        }
      }, 1000);
    }

    function updateCooldownUI() {
      const cooldownBtn = document.getElementById('cooldown-btn');
      const timerEl = document.getElementById('cooldown-timer');
      cooldownBtn.classList.remove('hidden');
      timerEl.textContent = cooldownSeconds;
    }

    function confirmVote() {
      if (selectedTeam === null || votedFor !== null || !votingOpen) return;
      socket.emit('vote', { teamId: selectedTeam, visitorId, visitorKey });
    }

    function updateStatus() {
      const cta = document.getElementById('cta');
      const totalVotersEl = document.getElementById('total-voters');
      cta.classList.remove('voted', 'closed');

      if (!votingOpen) {
        cta.classList.add('closed');
        // Find winner
        const maxVotes = Math.max(...teams.map(t => t.votes));
        const winners = teams.filter(t => t.votes === maxVotes && maxVotes > 0);
        if (winners.length === 1) {
          cta.textContent = `–ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winners[0].name}!`;
        } else if (winners.length > 1) {
          cta.textContent = '–ù–∏—á—å—è!';
        } else {
          cta.textContent = '–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ';
        }
        // Show results when voting is closed
        totalVotersEl.classList.add('visible');
      } else if (jokeMode) {
        // Joke mode - always show "tap to vote"
        cta.textContent = '–ù–∞–∂–∏–º–∞–π –Ω–∞ –∫–æ–º–∞–Ω–¥—É!';
        totalVotersEl.classList.remove('visible');
      } else if (votedFor !== null) {
        cta.classList.add('voted');
        cta.textContent = '–°–ø–∞—Å–∏–±–æ –∑–∞ –≥–æ–ª–æ—Å!';
        totalVotersEl.classList.remove('visible');
      } else {
        cta.textContent = '–ì–æ–ª–æ—Å—É–π –∑–∞ –ª—É—á—à—É—é –∫–æ–º–∞–Ω–¥—É!';
        totalVotersEl.classList.remove('visible');
      }
    }

    socket.on('state', (data) => {
      hideLoader();
      document.getElementById('round').textContent = data.round;
      document.getElementById('round-name').textContent = data.roundName || '';
      teams = data.teams;
      votingOpen = data.votingOpen;
      jokeMode = data.jokeMode || false;

      // Check if vote session changed (reset happened while offline)
      const savedVote = localStorage.getItem('current_vote');
      if (savedVote) {
        try {
          const voteData = JSON.parse(savedVote);
          if (voteData.voteSession !== data.voteSession) {
            // Session changed, clear old vote
            localStorage.removeItem('current_vote');
            votedFor = null;
          }
        } catch (e) {}
      }

      currentVoteSession = data.voteSession;

      // Server says we voted - trust it (only in normal mode)
      if (!jokeMode && data.votedFor !== null) {
        votedFor = data.votedFor;
        // Update localStorage with session
        try {
          localStorage.setItem('current_vote', JSON.stringify({ visitorId, teamId: votedFor, voteSession: currentVoteSession }));
        } catch (e) {}
      }

      renderTeams();
      updateStatus();
    });

    socket.on('results', (data) => {
      teams = data.teams;
      // Only update total-voters text, visibility controlled by updateResultsVisibility
      document.getElementById('total-voters').textContent = `${data.totalVoters} –≥–æ–ª–æ—Å–æ–≤`;
      renderTeams();
    });

    socket.on('voted', (teamId) => {
      votedFor = teamId;
      // Store in localStorage with session
      try {
        localStorage.setItem('current_vote', JSON.stringify({ visitorId, teamId, voteSession: currentVoteSession }));
      } catch (e) {}
      renderTeams();
      updateStatus();
    });

    socket.on('reset', (data) => {
      document.getElementById('round').textContent = data.round;
      document.getElementById('round-name').textContent = data.roundName || '';
      teams = data.teams;
      votedFor = null;
      selectedTeam = null;
      votingOpen = data.votingOpen;
      currentVoteSession = data.voteSession;
      document.getElementById('total-voters').textContent = '';
      // Clear localStorage vote
      try {
        localStorage.removeItem('current_vote');
      } catch (e) {}
      renderTeams();
      updateStatus();
    });

    socket.on('new-round', (data) => {
      document.getElementById('round').textContent = data.round;
      document.getElementById('round-name').textContent = data.roundName || '';
      teams = data.teams;
      votedFor = null;
      selectedTeam = null;
      votingOpen = data.votingOpen;
      currentVoteSession = data.voteSession;
      document.getElementById('total-voters').textContent = '';
      // Clear localStorage vote
      try {
        localStorage.removeItem('current_vote');
      } catch (e) {}
      renderTeams();
      updateStatus();

      // Show round announcement
      showRoundAnnouncement(data.round, data.roundName);
    });

    socket.on('voting-status', (data) => {
      const wasOpen = votingOpen;
      votingOpen = data.votingOpen;
      if (data.jokeMode !== undefined) {
        jokeMode = data.jokeMode;
      }
      // When voting closes, server sends results
      if (data.teams) {
        teams = data.teams;
      }
      if (data.totalVoters !== undefined) {
        document.getElementById('total-voters').textContent = `${data.totalVoters} –≥–æ–ª–æ—Å–æ–≤`;
      }
      renderTeams();
      updateStatus();

      // Hide progress bar when voting closes
      if (!votingOpen) {
        document.getElementById('vote-progress').classList.add('hidden');
      }

      // Mini confetti when voting closes
      if (wasOpen && !votingOpen) {
        miniConfetti();
      }
    });

    socket.on('joke-mode-changed', (data) => {
      jokeMode = data.jokeMode;
      // Reset state when mode changes
      votedFor = null;
      selectedTeam = null;
      jokeCooldown = false;
      if (cooldownTimer) {
        clearInterval(cooldownTimer);
        cooldownTimer = null;
      }
      document.getElementById('cooldown-btn').classList.add('hidden');
      try {
        localStorage.removeItem('current_vote');
      } catch (e) {}
      renderTeams();
      updateStatus();
    });

    socket.on('round-name-updated', (data) => {
      document.getElementById('round-name').textContent = data.roundName || '';
    });

    socket.on('teams-updated', (data) => {
      teams = data.teams;
      renderTeams();
    });

    socket.on('error', (msg) => {
      // Don't show alert for "already voted" - just update UI
      if (msg.includes('—É–∂–µ –≥–æ–ª–æ—Å–æ–≤–∞–ª–∏')) {
        updateStatus();
      } else {
        alert(msg);
      }
    });

    // Vote progress stats
    socket.on('vote-stats', (data) => {
      updateVoteProgress(data.totalVoters, data.connectedUsers, data.votePercent);
    });

    function updateVoteProgress(totalVoters, connectedUsers, votePercent) {
      const progressEl = document.getElementById('vote-progress');
      const fillEl = document.getElementById('progress-fill');
      const votedCountEl = document.getElementById('voted-count');
      const totalCountEl = document.getElementById('total-count');

      // Show progress bar only during active voting
      if (votingOpen && connectedUsers > 0) {
        progressEl.classList.remove('hidden');
        fillEl.style.width = votePercent + '%';
        votedCountEl.textContent = totalVoters;
        totalCountEl.textContent = connectedUsers;
      } else {
        progressEl.classList.add('hidden');
      }
    }

    function vote(teamId) {
      if (votedFor !== null || !votingOpen) return;
      socket.emit('vote', { teamId, visitorId, visitorKey });
    }
  </script>
</body>
</html>
