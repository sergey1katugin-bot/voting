<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #fafafa;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      color: #1a1a1a;
    }

    .header {
      text-align: center;
      margin-bottom: 32px;
    }

    .cta {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 16px;
      color: #1a1a1a;
    }

    .cta.voted {
      color: #43a047;
    }

    .cta.closed {
      color: #43a047;
    }

    .round-info {
      font-size: 1rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 500;
    }

    .round-name {
      font-size: 1.2rem;
      margin-top: 8px;
      color: #1a1a1a;
      font-weight: 600;
    }

    .round-name:empty {
      display: none;
    }

    .voting-container {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      width: 100%;
      max-width: 800px;
      justify-content: center;
    }

    .team-btn {
      flex: 1 1 calc(50% - 16px);
      min-width: 200px;
      max-width: 300px;
      padding: 40px 20px;
      border: 3px solid #1a1a1a;
      border-radius: 16px;
      font-size: 1.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      background: #fff;
      color: #1a1a1a;
    }

    .team-btn:hover:not(:disabled) {
      color: #fff;
      transform: scale(1.02);
    }

    .team-btn:active:not(:disabled) {
      transform: scale(0.98);
    }

    .team-btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .team-btn.selected {
      color: #fff;
    }

    .vote-count {
      font-size: 3rem;
      font-weight: 700;
      line-height: 1;
      display: none;
    }

    .vote-count.visible {
      display: block;
    }

    /* Winner styles */
    .team-btn.winner {
      transform: scale(1.08);
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      opacity: 1 !important;
      color: #fff;
      animation: winner-pulse 1.5s ease-in-out infinite;
    }

    .team-btn.loser {
      opacity: 0.4;
      transform: scale(0.95);
    }

    @keyframes winner-pulse {
      0%, 100% { box-shadow: 0 8px 32px rgba(0,0,0,0.2); }
      50% { box-shadow: 0 12px 48px rgba(0,0,0,0.3); }
    }

    .winner-badge {
      font-size: 1rem;
      background: #fff;
      color: #1a1a1a;
      padding: 8px 16px;
      border-radius: 24px;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 700;
      margin-top: 8px;
    }

    /* Tie styles */
    .team-btn.tied {
      color: #fff;
      opacity: 1;
    }

    .tie-badge {
      font-size: 0.9rem;
      background: rgba(255,255,255,0.9);
      color: #1a1a1a;
      padding: 6px 14px;
      border-radius: 20px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      margin-top: 8px;
    }

    .trophy {
      font-size: 2rem;
      line-height: 1;
    }

    /* Mini confetti */
    .confetti {
      position: fixed;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      animation: confetti-fall 2s ease-out forwards;
      z-index: 1000;
    }

    @keyframes confetti-fall {
      0% {
        opacity: 1;
        transform: translateY(0) rotate(0deg) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(100px) rotate(720deg) scale(0.5);
      }
    }

    .team-name {
      font-size: 1rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
    }

    .confirm-section {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      text-align: center;
      z-index: 100;
    }

    .confirm-btn {
      width: 100%;
      max-width: 400px;
      padding: 18px 48px;
      font-size: 1.2rem;
      font-weight: 600;
      border: 3px solid #43a047;
      border-radius: 12px;
      background: #43a047;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 16px rgba(67, 160, 71, 0.4);
    }

    .confirm-btn:hover {
      background: #388e3c;
      border-color: #388e3c;
      transform: scale(1.02);
    }

    .confirm-btn:active {
      transform: scale(0.98);
    }

    .confirm-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .confirm-btn.hidden {
      display: none;
    }


    .total-voters {
      margin-top: 24px;
      color: #999;
      font-size: 0.85rem;
      display: none;
    }

    .total-voters.visible {
      display: block;
    }

    .team-btn.winner {
      color: #fff;
      transform: scale(1.05);
    }

    @media (max-width: 480px) {
      .team-btn {
        flex: 1 1 100%;
        max-width: none;
        padding: 30px 20px;
      }

      .vote-count {
        font-size: 2.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="cta" id="cta">–ì–æ–ª–æ—Å—É–π –∑–∞ –ª—É—á—à—É—é –∫–æ–º–∞–Ω–¥—É!</div>
    <div class="round-info">–†–∞—É–Ω–¥ <span id="round">1</span></div>
    <div class="round-name" id="round-name"></div>
  </div>

  <div class="voting-container" id="voting-container">
    <!-- Teams will be rendered here -->
  </div>

  <div class="confirm-section" id="confirm-section">
    <button class="confirm-btn hidden" id="confirm-btn" onclick="confirmVote()">
      –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å
    </button>
  </div>

  <div class="total-voters" id="total-voters"></div>

  <!-- FingerprintJS for device identification -->
  <script src="https://cdn.jsdelivr.net/npm/@aspect-security/fingerprint-js@3.4.2/dist/fingerprint.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();

    // Request state immediately on connect
    socket.on('connect', () => {
      socket.emit('get-state');
    });

    let teams = [];
    let votedFor = null;        // Confirmed vote
    let selectedTeam = null;    // Pre-selected (not confirmed yet)
    let votingOpen = true;
    let visitorId = null;
    let visitorKey = null;
    let currentVoteSession = null;

    // Generate device fingerprint
    async function getFingerprint() {
      try {
        // Try localStorage first (persists across sessions)
        const stored = localStorage.getItem('voter_fingerprint');
        if (stored) {
          const data = JSON.parse(stored);
          visitorId = data.visitorId;
          visitorKey = data.visitorKey;
          return;
        }
      } catch (e) {}

      // Generate new fingerprint based on device characteristics
      const components = [
        navigator.userAgent,
        navigator.language,
        screen.width + 'x' + screen.height,
        screen.colorDepth,
        new Date().getTimezoneOffset(),
        navigator.hardwareConcurrency || 'unknown',
        navigator.platform,
        // Canvas fingerprint
        await getCanvasFingerprint()
      ];

      // Create hash
      const fingerprint = components.join('|');
      visitorId = await hashString(fingerprint);
      visitorKey = await hashString(fingerprint + Date.now() + Math.random());

      // Store in localStorage
      try {
        localStorage.setItem('voter_fingerprint', JSON.stringify({ visitorId, visitorKey }));
      } catch (e) {}
    }

    function getCanvasFingerprint() {
      return new Promise(resolve => {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 200;
          canvas.height = 50;

          ctx.textBaseline = 'top';
          ctx.font = '14px Arial';
          ctx.fillStyle = '#f60';
          ctx.fillRect(125, 1, 62, 20);
          ctx.fillStyle = '#069';
          ctx.fillText('Fingerprint', 2, 15);
          ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
          ctx.fillText('Fingerprint', 4, 17);

          resolve(canvas.toDataURL());
        } catch (e) {
          resolve('canvas-not-supported');
        }
      });
    }

    async function hashString(str) {
      const encoder = new TextEncoder();
      const data = encoder.encode(str);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Initialize
    async function init() {
      await getFingerprint();

      // Check if voted in localStorage
      const localVote = localStorage.getItem('current_vote');
      if (localVote) {
        try {
          const voteData = JSON.parse(localVote);
          if (voteData.visitorId === visitorId) {
            votedFor = voteData.teamId;
          }
        } catch (e) {}
      }

      // Register with server
      socket.emit('register-fingerprint', { visitorId, visitorKey });
    }

    init();

    // Re-sync state when user returns to page (after switching tabs/apps)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && visitorId) {
        socket.emit('register-fingerprint', { visitorId, visitorKey });
      }
    });

    function renderTeams() {
      const container = document.getElementById('voting-container');
      const isSelected = (id) => votedFor === id || selectedTeam === id;
      const showResults = !votingOpen; // Only show results when voting is closed

      // Find winner when showing results
      const maxVotes = showResults ? Math.max(...teams.map(t => t.votes)) : 0;
      const hasVotes = maxVotes > 0;
      const winnersCount = hasVotes ? teams.filter(t => t.votes === maxVotes).length : 0;
      const isTie = winnersCount > 1; // –ù–∏—á—å—è –µ—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–º–∞–Ω–¥ —Å max –≥–æ–ª–æ—Å–∞–º–∏

      // Sort teams: winner first, then by votes descending
      const sortedTeams = showResults
        ? [...teams].sort((a, b) => b.votes - a.votes)
        : teams;

      container.innerHTML = sortedTeams.map((team, index) => {
        const isWinner = showResults && hasVotes && !isTie && team.votes === maxVotes;
        const isLoser = showResults && hasVotes && !isTie && team.votes !== maxVotes;
        const isTied = showResults && hasVotes && isTie && team.votes === maxVotes;

        // Only disable during active voting if already voted, not when results shown
        const shouldDisable = votingOpen && votedFor !== null;

        // Trophy for places when showing results
        const place = showResults && hasVotes ? index + 1 : 0;
        const trophy = isTie ? '' : (place === 1 ? 'ü•á' : place === 2 ? 'ü•à' : place === 3 ? 'ü•â' : '');

        return `
          <button
            class="team-btn ${isSelected(team.id) ? 'selected' : ''} ${isWinner ? 'winner' : ''} ${isLoser ? 'loser' : ''} ${isTied ? 'tied' : ''}"
            style="border-color: ${team.color}; ${isSelected(team.id) || isWinner || isTied ? `background: ${team.color}` : ''}"
            data-id="${team.id}"
            data-color="${team.color}"
            ${shouldDisable ? 'disabled' : ''}
            onclick="selectTeam(${team.id})"
          >
            ${trophy ? `<span class="trophy">${trophy}</span>` : ''}
            <span class="team-name">${team.name}</span>
            <span class="vote-count ${showResults ? 'visible' : ''}">${team.votes}</span>
            ${isWinner ? '<span class="winner-badge">–ü–æ–±–µ–¥–∏—Ç–µ–ª—å</span>' : ''}
            ${isTied ? '<span class="tie-badge">–ù–∏—á—å—è</span>' : ''}
          </button>
        `;
      }).join('');

      // Add hover effects
      container.querySelectorAll('.team-btn:not(:disabled)').forEach(btn => {
        const color = btn.dataset.color;
        btn.addEventListener('mouseenter', () => {
          if (!btn.classList.contains('selected')) {
            btn.style.background = color;
          }
        });
        btn.addEventListener('mouseleave', () => {
          if (!btn.classList.contains('selected')) {
            btn.style.background = '#fff';
          }
        });
      });

      // Update confirm button
      updateConfirmButton();
    }

    // Mini confetti burst
    function miniConfetti() {
      const colors = ['#e53935', '#1e88e5', '#43a047', '#fb8c00', '#8e24aa', '#fdd835'];
      const count = 30;

      for (let i = 0; i < count; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.top = Math.random() * 40 + 'vh';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        document.body.appendChild(confetti);

        setTimeout(() => confetti.remove(), 2500);
      }
    }

    function updateConfirmButton() {
      const confirmBtn = document.getElementById('confirm-btn');

      if (votedFor !== null) {
        // Already voted
        confirmBtn.classList.add('hidden');
      } else if (selectedTeam !== null && votingOpen) {
        // Team selected, show confirm
        confirmBtn.classList.remove('hidden');
      } else {
        // Nothing selected
        confirmBtn.classList.add('hidden');
      }
    }

    function selectTeam(teamId) {
      if (votedFor !== null || !votingOpen) return;
      selectedTeam = teamId;
      renderTeams();
    }

    function confirmVote() {
      if (selectedTeam === null || votedFor !== null || !votingOpen) return;
      socket.emit('vote', { teamId: selectedTeam, visitorId, visitorKey });
    }

    function updateStatus() {
      const cta = document.getElementById('cta');
      const totalVotersEl = document.getElementById('total-voters');
      cta.classList.remove('voted', 'closed');

      if (!votingOpen) {
        cta.classList.add('closed');
        // Find winner
        const maxVotes = Math.max(...teams.map(t => t.votes));
        const winners = teams.filter(t => t.votes === maxVotes && maxVotes > 0);
        if (winners.length === 1) {
          cta.textContent = `–ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winners[0].name}!`;
        } else if (winners.length > 1) {
          cta.textContent = '–ù–∏—á—å—è!';
        } else {
          cta.textContent = '–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ';
        }
        // Show results when voting is closed
        totalVotersEl.classList.add('visible');
      } else if (votedFor !== null) {
        cta.classList.add('voted');
        cta.textContent = '–°–ø–∞—Å–∏–±–æ –∑–∞ –≥–æ–ª–æ—Å!';
        totalVotersEl.classList.remove('visible');
      } else {
        cta.textContent = '–ì–æ–ª–æ—Å—É–π –∑–∞ –ª—É—á—à—É—é –∫–æ–º–∞–Ω–¥—É!';
        totalVotersEl.classList.remove('visible');
      }
    }

    socket.on('state', (data) => {
      document.getElementById('round').textContent = data.round;
      document.getElementById('round-name').textContent = data.roundName || '';
      teams = data.teams;
      votingOpen = data.votingOpen;

      // Check if vote session changed (reset happened while offline)
      const savedVote = localStorage.getItem('current_vote');
      if (savedVote) {
        try {
          const voteData = JSON.parse(savedVote);
          if (voteData.voteSession !== data.voteSession) {
            // Session changed, clear old vote
            localStorage.removeItem('current_vote');
            votedFor = null;
          }
        } catch (e) {}
      }

      currentVoteSession = data.voteSession;

      // Server says we voted - trust it
      if (data.votedFor !== null) {
        votedFor = data.votedFor;
        // Update localStorage with session
        try {
          localStorage.setItem('current_vote', JSON.stringify({ visitorId, teamId: votedFor, voteSession: currentVoteSession }));
        } catch (e) {}
      }

      renderTeams();
      updateStatus();
    });

    socket.on('results', (data) => {
      teams = data.teams;
      // Only update total-voters text, visibility controlled by updateResultsVisibility
      document.getElementById('total-voters').textContent = `${data.totalVoters} –≥–æ–ª–æ—Å–æ–≤`;
      renderTeams();
    });

    socket.on('voted', (teamId) => {
      votedFor = teamId;
      // Store in localStorage with session
      try {
        localStorage.setItem('current_vote', JSON.stringify({ visitorId, teamId, voteSession: currentVoteSession }));
      } catch (e) {}
      renderTeams();
      updateStatus();
    });

    socket.on('reset', (data) => {
      document.getElementById('round').textContent = data.round;
      document.getElementById('round-name').textContent = data.roundName || '';
      teams = data.teams;
      votedFor = null;
      selectedTeam = null;
      votingOpen = data.votingOpen;
      currentVoteSession = data.voteSession;
      document.getElementById('total-voters').textContent = '';
      // Clear localStorage vote
      try {
        localStorage.removeItem('current_vote');
      } catch (e) {}
      renderTeams();
      updateStatus();
    });

    socket.on('new-round', (data) => {
      document.getElementById('round').textContent = data.round;
      document.getElementById('round-name').textContent = data.roundName || '';
      teams = data.teams;
      votedFor = null;
      selectedTeam = null;
      votingOpen = data.votingOpen;
      currentVoteSession = data.voteSession;
      document.getElementById('total-voters').textContent = '';
      // Clear localStorage vote
      try {
        localStorage.removeItem('current_vote');
      } catch (e) {}
      renderTeams();
      updateStatus();
    });

    socket.on('voting-status', (data) => {
      const wasOpen = votingOpen;
      votingOpen = data.votingOpen;
      // When voting closes, server sends results
      if (data.teams) {
        teams = data.teams;
      }
      if (data.totalVoters !== undefined) {
        document.getElementById('total-voters').textContent = `${data.totalVoters} –≥–æ–ª–æ—Å–æ–≤`;
      }
      renderTeams();
      updateStatus();

      // Mini confetti when voting closes
      if (wasOpen && !votingOpen) {
        miniConfetti();
      }
    });

    socket.on('round-name-updated', (data) => {
      document.getElementById('round-name').textContent = data.roundName || '';
    });

    socket.on('teams-updated', (data) => {
      teams = data.teams;
      renderTeams();
    });

    socket.on('error', (msg) => {
      // Don't show alert for "already voted" - just update UI
      if (msg.includes('—É–∂–µ –≥–æ–ª–æ—Å–æ–≤–∞–ª–∏')) {
        updateStatus();
      } else {
        alert(msg);
      }
    });

    function vote(teamId) {
      if (votedFor !== null || !votingOpen) return;
      socket.emit('vote', { teamId, visitorId, visitorKey });
    }
  </script>
</body>
</html>
